<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Twitch Sound List</title>
<style>
  body {
    font-family: Arial, sans-serif;
    padding: 20px;
    background: linear-gradient(270deg in oklab, #4d480a, #120b49, #410d47, #043306);
    background-size: 400% 400%;
    animation: gradientBG 60s linear infinite alternate;
    transition: background 0.5s ease, color 0.5s ease;
    color: transparent;
  }

  @keyframes gradientBG {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
  }

  /* Light mode override */
  body.lightmode {
    background: linear-gradient(270deg in oklab, #e2d522, #3b27f0, #cc26e2, #18d821);
    background-size: 400% 400%;
    animation: gradientBG 60s linear infinite alternate;
    color: transparent;
  }

  /* Sound item cards with frosted glass effect */
  .sound-item {
    display: flex;
    align-items: center;
    margin: 10px 0;
    padding: 10px;
    border: 2px solid #000; /* default border */
    border-radius: 12px;    /* rounded edges */
    background: rgba(0,0,0,0.3); /* dark overlay */
    backdrop-filter: blur(6px);   /* frosted glass effect */
    transition: background 0.5s ease, border-color 0.5s ease, color 0.5s ease;
  }

  .sound-item img { 
    width: 50px; 
    height: 50px; 
    object-fit: contain; 
    margin-right: 15px; 
    border-radius: 5px; 
    background: transparent; 
  }

  .sound-item button { 
    margin-left: auto; 
    padding: 5px 10px; 
    cursor: pointer; 
    transition: transform 0.2s ease; 
  }

  .sound-item button:hover {
    transform: scale(1.2);
  }

  #twitchImg:hover {
  transform: scale(1.2);
  transition: transform 0.2s ease;
}

  .sound-item div {
    color: #fff;
    text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
  }

  /* Light mode override for cards */
  body.lightmode .sound-item {
    border: 5px solid #000;
    background: rgba(255,255,255,0.6); 
    border-color: #000;
  }

  body.lightmode .sound-item div {
    color: #000; 
    text-shadow: 1px 1px 2px rgba(255,255,255,0.5);
  }

  body.lightmode .sound-item a {
    color: #000;
  }

  .sound-item a {
    color: #fff;
    text-decoration: underline;
  }

  .container { max-width: 900px; margin: 0 auto; }
  
  /* Header color and light/dark mode support */
.container > h1 {
    color: #fff;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
    margin-bottom: 15px;
}

body.lightmode .container > h1 {
    color: #000;
    text-shadow: 1px 1px 2px rgba(255,255,255,0.5);
}

/* Contact Button Wrapper */
.contact-card {
  display: inline-block;
  padding: 15px;
  border-radius: 16px;
  border: 2px solid #000;
  background: rgba(0,0,0,0.3);
  backdrop-filter: blur(6px);
  transition: all 0.3s ease;
}

/* Glow on hover */
.contact-card:hover {
  box-shadow: 0 0 20px rgba(255,255,255,0.8);
  transform: scale(1.05);
}

/* Light mode override */
body.lightmode .contact-card {
  background: rgba(255,255,255,0.6);
  border: 2px solid #000;
}

body.lightmode .contact-card:hover {
  box-shadow: 0 0 20px rgba(0,0,0,0.7);
}

#toggleMode {
  background: none !important;
  border: none !important;
  box-shadow: none !important;
  backdrop-filter: none !important;
}

body.lightmode #toggleMode {
  background: none !important;
}

/* Animated loading spinner */
.spinner {
  width: 20px;
  height: 20px;
  border: 3px solid rgba(255,255,255,0.3);
  border-top-color: white;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-left: auto;
  display: none;
}

body.lightmode .spinner {
  border: 3px solid rgba(0,0,0,0.3);
  border-top-color: black;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}
/* Blurred transparent overlay for loading */
.spinner-overlay {
  position: absolute;
  inset: 0;
  background: rgba(0,0,0,0.4);
  backdrop-filter: blur(4px);
  border-radius: 12px;
  display: none;
}

body.lightmode .spinner-overlay {
  background: rgba(255,255,255,0.4);
}



</style>
</head>
<body>
<div class="container">
  <h1>Emote Sounds</h1>
  <button id="toggleMode">ðŸŒ™</button>

    <div id="list"></div>

  <!-- Contact Me Button -->
  <div style="text-align:center; margin-top:40px;">
    <a href="https://twitch.tv/windowsben" target="_blank" class="contact-card">
      <img 
        src="https://files.catbox.moe/c65dyt.png"
        alt="Contact Me"
        style="width:120px; height:auto; border-radius:12px; cursor:pointer;">
    </a>
  </div>

</div>





<script>
// Local JSON files stored in the repo
const userFiles = {
  Amedoll: "lists/Amedoll.json",
  Boshiitime: "lists/BoshiiTime.json",
  Favorite: "lists/Favorite.json",
  Fubuki_Vr: "lists/Fubuki_Vr.json",
  Greywolf: "lists/Greywolf.json",
  HeyImRadiant: "lists/HeyImRadiant.json",
  Jakkuba_VR: "lists/Jakkuba_VR.json",
  Kasimina: "lists/Kasimina.json",
  Kohrean: "lists/Kohrean.json",
  Krisuna: "lists/Krisuna.json",
  Kromia: "lists/Kromia.json",
  La_Wafflez: "lists/La_Wafflez.json",
  Luuna: "lists/Luuna.json",
  Puck: "lists/Puck.json",
  RadiantSoul_Tv: "lists/RadiantSoul_Tv.json",
  RinMunchkin: "lists/RinMunchkin.json",
  SKTKawaiiNeko: "lists/SKTKawaiiNeko.json",
  Taletrap: "lists/Taletrap.json",
  Totless: "lists/Totless.json"
};

// Toggle dark/light mode
const toggleBtn = document.getElementById("toggleMode");
toggleBtn.addEventListener("click", () => {
  document.body.classList.toggle("lightmode");
  toggleBtn.textContent = document.body.classList.contains("lightmode") ? "â˜€ï¸" : "ðŸŒ™";
});

let triggerImages = {};



async function loadTriggerImages() {
  try {
    const res = await fetch("lists/internals/IconTriggers.json");
    triggerImages = await res.json();
    console.log("Loaded trigger images:", triggerImages);
  } catch (err) {
    console.error("Failed to load trigger images:", err);
  }
}

loadTriggerImages();

let avatars = {};

async function loadAvatars() {
  try {
    const res = await fetch("lists/internals/avatars.json");
    avatars = await res.json();
    console.log("Loaded avatars:", avatars);
  } catch (err) {
    console.error("Failed to load avatars:", err);
  }
}

loadAvatars();

// Shared AudioContext for per-item playback/reverse operations
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

// Helper: fetch + decode to AudioBuffer (cached per URL by caller)
async function fetchAndDecode(url) {
  const res = await fetch(url);
  const arrayBuffer = await res.arrayBuffer();
  return await audioCtx.decodeAudioData(arrayBuffer);
}



// Load available user lists on page load
window.addEventListener("DOMContentLoaded", async () => {
  await loadTriggerImages();
  displayUserLists();
});


function displayUserLists() {
    const container = document.getElementById("list");
    container.innerHTML = ""; // clear previous content

    // 1ï¸âƒ£ Create search input at the top of the user list
    const searchInput = document.createElement("input");
    searchInput.type = "text";
    searchInput.placeholder = "Search users...";
    searchInput.style.marginBottom = "15px";
    searchInput.style.padding = "8px 12px";
    searchInput.style.width = "300px"; // adjust as needed
    searchInput.style.fontSize = "16px";
    searchInput.style.borderRadius = "12px";
    searchInput.style.border = "2px solid #000";
    searchInput.style.background = "rgba(0,0,0,0.3)";
    searchInput.style.backdropFilter = "blur(6px)";
    searchInput.style.color = "#fff";
    searchInput.style.outline = "none";
    searchInput.style.transition = "all 0.3s ease";
    searchInput.addEventListener("focus", () => searchInput.style.borderColor = "#fff");
    searchInput.addEventListener("blur", () => searchInput.style.borderColor = "#000");

    container.appendChild(searchInput);

    // 2ï¸âƒ£ Array to store user divs for filtering
    const userDivs = [];

    // 3ï¸âƒ£ Create the user divs
    Object.keys(userFiles).forEach(user => {
        const div = document.createElement("div");
        div.className = "sound-item";
        div.style.cursor = "pointer";

        // Twitch avatar
        const twitchImg = document.createElement("img");
        twitchImg.src = avatars[user] || "https://static.twitchcdn.net/assets/favicon-32-e29e246c157142c94346.png";
        twitchImg.alt = user;

        // Twitch profile link
        const twitchLink = document.createElement("a");
        twitchLink.href = `https://twitch.tv/${user}`;
        twitchLink.target = "_blank";
        twitchLink.appendChild(twitchImg);
        div.appendChild(twitchLink);

        // Text label
        const text = document.createElement("div");
        text.innerHTML = `<strong>${user}</strong><br><span>Click to view sounds</span>`;
        div.appendChild(text);

        // Click container to load user's sounds
        div.addEventListener("click", (e) => {
            if (e.target.tagName.toLowerCase() === 'img' || e.target.closest('a')) return;
            loadList(user);
        });

        container.appendChild(div);

        // Add to array for filtering
        userDivs.push({div, name: user.toLowerCase()});
    });

    // 4ï¸âƒ£ Filter users on input
    searchInput.addEventListener("input", () => {
        const query = searchInput.value.toLowerCase();
        userDivs.forEach(obj => {
            obj.div.style.display = obj.name.includes(query) ? "flex" : "none";
        });
    });
}


// Load list for selected user
async function loadList(user) {
  try {
    const res = await fetch(userFiles[user]);
    const data = await res.json();

    const list = Array.isArray(data)
      ? data
      : Object.values(data).find(v => Array.isArray(v)) || [];

    displayList(list, user);
  } catch (error) {
    console.error("Error loading list:", error);
    document.getElementById("list").innerHTML = "<p style='color:red;'>Failed to load list.</p>";
  }
}

function displayList(list, user) {
    const container = document.getElementById("list");
    container.innerHTML = ''; // clear the container first

    // 1ï¸âƒ£ Back button + search wrapper
    const headerWrapper = document.createElement("div");
    headerWrapper.style.display = "flex";
    headerWrapper.style.alignItems = "center";
    headerWrapper.style.justifyContent = "space-between";
    headerWrapper.style.gap = "12px";
    headerWrapper.style.marginBottom = "15px";

    // Back button
    const backButton = document.createElement("button");
    backButton.id = "backButton";
    backButton.style.padding = "8px 12px";
    backButton.style.fontSize = "16px";
    backButton.style.color = "#fff";
    backButton.style.borderRadius = "8px";
    backButton.style.border = "2px solid #000";
    backButton.style.background = "rgba(0,0,0,0.3)";
    backButton.style.backdropFilter = "blur(6px)";
    backButton.style.cursor = "pointer";
    backButton.textContent = "â¬… Back";
    backButton.addEventListener("click", () => displayUserLists());

    // Search input
    const searchInput = document.createElement("input");
    searchInput.type = "text";
    searchInput.placeholder = "Search emotes...";
    searchInput.style.padding = "10px";
    searchInput.style.width = "300px";
    searchInput.style.fontSize = "16px";
    searchInput.style.borderRadius = "12px";
    searchInput.style.border = "2px solid #000";
    searchInput.style.background = "rgba(0,0,0,0.3)";
    searchInput.style.backdropFilter = "blur(6px)";
    searchInput.style.color = "#fff";
    searchInput.style.outline = "none";
    searchInput.style.transition = "all 0.3s ease";
    searchInput.addEventListener("focus", () => searchInput.style.borderColor = "#fff");
    searchInput.addEventListener("blur", () => searchInput.style.borderColor = "#000");

    headerWrapper.appendChild(backButton);
    headerWrapper.appendChild(searchInput);
    container.appendChild(headerWrapper);

    if (list.length === 0) {
        container.innerHTML += "<p>No sounds found in this list.</p>";
        return;
    }

    // store emote nodes for search filtering
    const emoteDivs = [];

    // For each item create UI and per-item audio handling
    list.forEach(item => {
        if (!item.enabled || item.enabled !== "true") return;

        const div = document.createElement("div");
        div.className = "sound-item";
        div.style.position = "relative";
        // Loading overlay
          const overlay = document.createElement("div");
          overlay.className = "spinner-overlay";
          div.appendChild(overlay);

        // CSS spinner
          const spinner = document.createElement("div");
          spinner.className = "spinner";
          overlay.appendChild(spinner);

        div.style.display = "flex";
        div.style.alignItems = "center";
        div.style.gap = "10px";

        // Emote image/anchor
        const emoteData = triggerImages[item.trigger_word];
        const emoteImgSrc = emoteData?.image || "https://files.catbox.moe/ab5icu.png";
        const emoteLink = emoteData?.link || "#";

        const emoteAnchor = document.createElement("a");
        emoteAnchor.href = emoteLink;
        emoteAnchor.target = "_blank";

        const emoteImg = document.createElement("img");
        emoteImg.src = emoteImgSrc;
        emoteImg.alt = item.trigger_word;
        emoteImg.style.cursor = "pointer";
        emoteImg.style.background = "transparent";

        emoteAnchor.appendChild(emoteImg);
        div.appendChild(emoteAnchor);

        // Text column
        const text = document.createElement("div");
        text.style.flex = "1";
        text.innerHTML = `<strong>${item.trigger_word}</strong><br><a href="${item.sound}" target="_blank">Sound Link</a>`;
        div.appendChild(text);

        // ---- Per-item controls container (volume slider, reverse button, pitch input) ----
        const controls = document.createElement("div");
        controls.style.display = "flex";
        controls.style.flexDirection = "column";
        controls.style.alignItems = "flex-end";
        controls.style.gap = "6px";
        controls.style.minWidth = "120px";

        // Volume slider (0-100)
        const volLabel = document.createElement("label");
        volLabel.style.fontSize = "12px";
        volLabel.style.marginBottom = "2px";
        volLabel.textContent = "Vol";

        const volInput = document.createElement("input");
        volInput.type = "range";
        volInput.min = "0";
        volInput.max = "100";
        // initial value: use item.volume if present (0-1), else 5 (5%)
        volInput.value = (typeof item.volume === "number") ? Math.round(item.volume * 100) : 50;
        volInput.style.width = "100px";

        // Reverse play button
        const reverseBtn = document.createElement("button");
        reverseBtn.textContent = "Reverse â–¶";
        reverseBtn.title = "Play reversed";
        reverseBtn.style.padding = "6px 8px";
        reverseBtn.style.fontSize = "12px";
        reverseBtn.style.cursor = "pointer";

        // Pitch/speed input (%) - Option B: playbackRate
        const pitchRow = document.createElement("div");
        pitchRow.style.display = "flex";
        pitchRow.style.alignItems = "center";
        pitchRow.style.gap = "6px";

        const pitchLabel = document.createElement("label");
        pitchLabel.style.fontSize = "12px";
        pitchLabel.textContent = "Speed";

        const pitchInput = document.createElement("input");
        pitchInput.type = "number";
        pitchInput.min = "50";
        pitchInput.max = "200";
        pitchInput.value = "100"; // default 100%
        pitchInput.style.width = "60px";
        pitchInput.style.fontSize = "12px";

        pitchRow.appendChild(pitchLabel);
        pitchRow.appendChild(pitchInput);

        // Append controls
        const volWrapper = document.createElement("div");
        volWrapper.style.display = "flex";
        volWrapper.style.flexDirection = "column";
        volWrapper.style.alignItems = "flex-end";
        volWrapper.appendChild(volLabel);
        volWrapper.appendChild(volInput);

        controls.appendChild(volWrapper);
        controls.appendChild(pitchRow);
        controls.appendChild(reverseBtn);

        div.appendChild(controls);

        // ---------- Per-item audio state & helpers ----------
        // cache decoded forward and reversed buffers per item
        let forwardBuffer = null;
        let reversedBuffer = null;
        let currentSource = null;
        let currentGain = null;

        // helper: ensure buffer is decoded (first element of item.sound or string)
        async function ensureBuffers() {
            if (forwardBuffer) return;
              spinner.style.display = "block"; // show spinner while decoding
              overlay.style.display = "block"; 
            try {
              // Pick a random URL
                let srcUrl;
              if (Array.isArray(item.sound)) {
                const idx = Math.floor(Math.random() * item.sound.length);
                srcUrl = item.sound[idx];
              } else {
            srcUrl = item.sound;
           }

        forwardBuffer = await fetchAndDecode(srcUrl);
                // build reversed buffer now too for quick reverse playback
                const numChannels = forwardBuffer.numberOfChannels;
                reversedBuffer = audioCtx.createBuffer(
                    numChannels,
                    forwardBuffer.length,
                    forwardBuffer.sampleRate
                );
                for (let c = 0; c < numChannels; c++) {
                    const chData = forwardBuffer.getChannelData(c);
                    const revCh = reversedBuffer.getChannelData(c);
                    for (let i = 0, L = chData.length; i < L; i++) {
                        revCh[i] = chData[L - 1 - i];
                    }
                }
              spinner.style.display = "none"; // hide spinner after decode
              overlay.style.display = "none"
            } catch (err) {
                console.error("Failed to load/prepare audio for", item.trigger_word, err);
                spinner.style.display = "none"; // hide spinner if failed
                overlay.style.display = "none";
                throw err;
            }
        }

        // helper: stop currently playing node for this item
        function stopCurrent() {
            try {
                if (currentSource) {
                    currentSource.stop(0);
                    currentSource.disconnect();
                    currentSource = null;
                }
                if (currentGain) {
                    currentGain.disconnect();
                    currentGain = null;
                }
            } catch (e) {
                // ignore
            }
        }

        // play buffer (forward or reversed) with current settings
        async function playBuffer(bufferToPlay) {
    await ensureBuffers();
    
    const src = audioCtx.createBufferSource();
    src.buffer = bufferToPlay;

    // pitch input is percent: 100 -> 1.0
    const rate = Math.max(0.01, (parseFloat(pitchInput.value) || 100) / 100);
    src.playbackRate.value = rate;

    const gainNode = audioCtx.createGain();
    gainNode.gain.value = (parseFloat(volInput.value) || 50) / 100;

    src.connect(gainNode).connect(audioCtx.destination);
    src.start(0);

    // auto-clear when done
    src.onended = () => {
        src.disconnect();
        gainNode.disconnect();
    };
}


        // container click: play forward (unless clicking the emote link)
        div.addEventListener("click", async (e) => {
            if (e.target.closest('a')) return; // clicking emote link should only navigate
            try {
                await ensureBuffers();
                await playBuffer(forwardBuffer);
            } catch (err) {
                console.error("Play error:", err);
            }
        });

        // reverse button: play reversed buffer
        reverseBtn.addEventListener("click", async (e) => {
            e.stopPropagation(); // prevent container click
            try {
                await ensureBuffers();
                await playBuffer(reversedBuffer);
            } catch (err) {
                console.error("Reverse play error:", err);
            }
        });

        // Volume slider live update (affects currently playing, and future plays)
        volInput.addEventListener("input", () => {
            if (currentGain) currentGain.gain.value = (parseFloat(volInput.value) || 50) / 100;
        });

        // Pitch input change only affects next play (source.playbackRate is set when starting)
        pitchInput.addEventListener("keydown", (ev) => {
            if (ev.key === "Enter") ev.target.blur();
        });

        // Add to DOM
        container.appendChild(div);

        // Add to emoteDivs array for search filtering
        emoteDivs.push({div, trigger_word: item.trigger_word.toLowerCase()});
    }); // end list.forEach

    // 5ï¸âƒ£ Filter on input
    searchInput.addEventListener("input", () => {
        const query = searchInput.value.toLowerCase();
        emoteDivs.forEach(obj => {
            obj.div.style.display = obj.trigger_word.includes(query) ? "flex" : "none";
        });
    });
}


</script>
</body>
</html>